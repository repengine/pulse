# Module Analysis: `forecast_engine/forecast_tracker.py`

## 1. Purpose

The [`forecast_tracker.py`](../../forecast_engine/forecast_tracker.py:1) module is responsible for managing the lifecycle of simulation forecasts within the Pulse system. Its primary functions include tracking, scoring, validating, and logging these forecasts. Trusted forecasts are saved to the `/forecast_output/` directory (as configured via [`core.path_registry.PATHS`](../../core/path_registry.py:0)) and can be optionally archived to a persistent forecast memory. A key feature is the attachment of detailed rule audit logs to each saved forecast, providing traceability and context.

## 2. Key Functionalities

The module centers around the `ForecastTracker` class:

*   **Initialization (`__init__`)**:
    *   Sets up the directory for logging forecast summaries, defaulting to a path derived from `PATHS["BATCH_FORECAST_SUMMARY"]`.
    *   Ensures the log directory exists.
*   **Forecast Recording (`record_forecast`)**:
    *   Takes a `forecast_id`, the simulation `WorldState`, a `rule_log` (containing executed rules and audit information), and an optional `domain` tag.
    *   Scores the forecast using [`forecast_engine.forecast_scoring.score_forecast()`](../../forecast_engine/forecast_scoring.py:0).
    *   Attaches the `rule_log` to the forecast's metadata.
    *   Validates the forecast's integrity using [`forecast_engine.forecast_integrity_engine.validate_forecast()`](../../forecast_engine/forecast_integrity_engine.py:0), checking for required keys like "confidence" and "symbolic_driver".
    *   If validation fails (low trust), the forecast is rejected, and a warning is logged.
    *   If trusted, it generates a unique filename, saves the forecast data (including ID, timestamp, state snapshot, metadata, and domain) as a JSON file in the configured log directory.
    *   Saves the forecast to persistent memory using [`forecast_engine.forecast_memory.save_forecast_to_memory()`](../../forecast_engine/forecast_memory.py:0).
    *   Logs a success message and returns the filepath of the saved forecast.
*   **Forecast Loading (`load_forecast`)**:
    *   Loads a forecast from a given JSON filepath.
    *   Raises a `FileNotFoundError` if the file doesn't exist.
*   **Listing Forecasts (`list_forecasts`)**:
    *   Returns a sorted list of all `.json` forecast files in the log directory.
*   **Filename Generation (`_generate_filename`)**:
    *   A private helper method to create a timestamped and uniquely identified filename for storing a forecast.

## 3. Role within `forecast_engine/`

Within the `forecast_engine/` directory, [`forecast_tracker.py`](../../forecast_engine/forecast_tracker.py:1) acts as a central hub for the post-generation processing of forecasts. It orchestrates scoring, validation, and persistence, ensuring that forecasts generated by other parts of the engine are properly evaluated and stored if they meet the system's trust criteria. It bridges the gap between raw forecast generation and their archival or further use.

## 4. Dependencies

### External Libraries:
*   `os`: For path manipulations and directory creation.
*   `json`: For serializing and deserializing forecast data to/from JSON files.
*   `datetime`: For timestamping forecasts.
*   `typing.Optional`: For type hinting.

### Internal Pulse Modules:
*   [`forecast_engine.forecast_scoring`](../../forecast_engine/forecast_scoring.py:0): Specifically, the `score_forecast` function.
*   [`forecast_engine.forecast_memory`](../../forecast_engine/forecast_memory.py:0): Specifically, the `save_forecast_to_memory` function.
*   [`forecast_engine.forecast_integrity_engine`](../../forecast_engine/forecast_integrity_engine.py:0): Specifically, the `validate_forecast` function.
*   [`engine.worldstate.WorldState`](../../simulation_engine/worldstate.py:0): As the type for the simulation state being recorded.
*   [`utils.log_utils.get_logger`](../../utils/log_utils.py:0): For application-level logging.
*   [`analytics.forecast_memory.ForecastMemory`](../../memory/forecast_memory.py:0): For initializing a forecast memory instance (though `save_forecast_to_memory` from `forecast_engine.forecast_memory` is used for saving).
*   [`core.path_registry.PATHS`](../../core/path_registry.py:0): For accessing configured directory paths for logging and forecast history.

## 5. Adherence to SPARC Principles

*   **Simplicity**: The module maintains a clear focus. The `ForecastTracker` class has a well-defined responsibility, and its methods are generally straightforward. The logic flow, especially in `record_forecast`, is easy to follow.
*   **Iterate**: The module integrates and orchestrates functionalities from other specialized modules (scoring, validation, memory storage), indicating an iterative build-up of capabilities. The comment "Now also attaches detailed rule audit logs" suggests incremental improvement.
*   **Focus**: The module is sharply focused on the task of tracking, validating, and persisting forecasts. It doesn't overstep into forecast generation or complex analysis.
*   **Quality**:
    *   Good use of type hinting enhances readability and maintainability.
    *   Logging is implemented for significant events (rejection, successful recording).
    *   File and directory operations are handled robustly (e.g., `os.makedirs(exist_ok=True)`).
    *   Docstrings are present at the module level and for the primary public method (`record_forecast`).
    *   Configuration of paths via [`core.path_registry.PATHS`](../../core/path_registry.py:0) promotes maintainability.
    *   An `assert` statement is used to validate the type of `PATHS`.
*   **Collaboration**: The module effectively collaborates with several other components across the Pulse ecosystem (`forecast_engine`, `simulation_engine`, `memory`, `utils`, `core`), acting as an integrator for forecast post-processing.

## 6. Overall Assessment

*   **Completeness**: The module appears functionally complete for its defined scope. It covers the essential aspects of recording, loading, and listing forecasts, along with the critical steps of scoring and validation.
*   **Clarity**: The code is well-structured and generally easy to understand. Method names are descriptive, and the internal logic is not overly complex. The separation of concerns, by delegating tasks like scoring and validation to other modules, contributes to its clarity.
*   **Quality**: The module demonstrates good software engineering practices. It is well-organized, uses standard libraries effectively, incorporates logging and basic error handling (like `FileNotFoundError`), and is reasonably documented. The integration with the `PATHS` registry for managing file locations is a good design choice.

This module serves as a crucial component for ensuring the reliability and traceability of forecasts generated by the Pulse system.